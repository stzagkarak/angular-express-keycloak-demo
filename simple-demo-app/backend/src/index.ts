import express from "express";
import cookieParser from "cookie-parser";
import cors from "cors";
import helmet from "helmet";
import jwt from "jsonwebtoken";
import { config } from "dotenv";
import path from "path";
import { Issuer, Client, generators } from "openid-client";
import crypto from "crypto";

if (process.env.NODE_ENV !== "production") {
  config(); // .env dev config
  // production node image loads backend.prod.env automatically
}

// User interface
interface User {
  id: string;
  email: string;
  preferred_username: string;
  roles?: string[];
  idToken?: string;
}

declare global {
  namespace Express {
    interface User {
      id: string;
      email: string;
      preferred_username: string;
      roles?: string[];
      idToken?: string;
    }

    interface Request {
      user?: User;
    }
  }
}

const app = express();
const PORT = parseInt(process.env.PORT as string);

if (process.env.PROXY_EXISTS === "1") {
  app.set("trust proxy", 1); // Trust first proxy for secure cookies in production
}

let staticPath = path.join(__dirname, "/../public");
if (process.env.DOCKER_EXISTS === "1") {
  staticPath = "/app/public"; // Docker container public path
}
app.use(express.static(staticPath));

// Security middleware
app.use(helmet());
app.use(
  cors({
    origin: process.env.FRONTEND_URL as string,
    credentials: true,
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization", "Cookie"],
  })
);

app.use(express.json());
app.use(cookieParser());

// Keycloak OIDC Configuration
const KEYCLOAK_CONFIG = {
  issuer: process.env.KEYCLOAK_ISSUER as string,
  clientID: process.env.KEYCLOAK_CLIENT_ID as string,
  clientSecret: process.env.KEYCLOAK_CLIENT_SECRET as string,
  callbackURL: process.env.KEYCLOAK_CALLBACK_URL as string,
};

// Initialize OpenID Client
let keycloakIssuer: any;
let oidc_client: Client;

const initializeOIDCClient = async () => {
  try {
    keycloakIssuer = await Issuer.discover(KEYCLOAK_CONFIG.issuer);
    console.log("Discovered issuer:", keycloakIssuer.issuer);

    oidc_client = new keycloakIssuer.Client({
      client_id: KEYCLOAK_CONFIG.clientID,
      client_secret: KEYCLOAK_CONFIG.clientSecret,
      redirect_uris: [KEYCLOAK_CONFIG.callbackURL],
      response_types: ["code"],
    });

    console.log("OIDC Client initialized successfully");
  } catch (error) {
    console.error("Failed to initialize OIDC client:", error);
    process.exit(1);
  }
};

// JWT-based auth (modern alternative)
const JWT_SECRET = process.env.JWT_SECRET as string;

const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY as string; // 32 bytes key

const encrypt = (text: string): string => {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv("aes-256-cbc", ENCRYPTION_KEY, iv);
  let encrypted = cipher.update(text, "utf8", "hex");
  encrypted += cipher.final("hex");
  return iv.toString("hex") + ":" + encrypted;
};

const decrypt = (text: string): string => {
  const textParts = text.split(":");
  const iv = Buffer.from(textParts.shift()!, "hex");
  const encryptedText = textParts.join(":");
  const decipher = crypto.createDecipheriv("aes-256-cbc", ENCRYPTION_KEY, iv);
  let decrypted = decipher.update(encryptedText, "hex", "utf8");
  decrypted += decipher.final("utf8");
  return decrypted;
};

// Do not confuse the token name with OpenID Connect access tokens
// these are JWT tokens generated by our backend for session management
const generateJWT = (user: User, oidcRefreshToken: string) => {
  const encryptedRefreshToken = encrypt(oidcRefreshToken);

  return jwt.sign(
    {
      id: user.id,
      email: user.email,
      roles: user.roles,
      oidcRefreshToken: encryptedRefreshToken,
    },
    JWT_SECRET,
    { expiresIn: "15m" }
  );
};

const storePKCEInCookie = (
  res: express.Response,
  codeVerifier: string,
  state: string
) => {
  const pkceData = JSON.stringify({ codeVerifier, state });
  const encryptedPKCE = encrypt(pkceData);

  res.cookie("pkce_data", encryptedPKCE, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "lax",
    maxAge: 10 * 60 * 1000, // 10 minutes - short lived
  });
};

const retrievePKCEFromCookie = (
  req: express.Request
): { codeVerifier: string; state: string } | null => {
  const encryptedPKCE = req.cookies.pkce_data;
  if (!encryptedPKCE) return null;

  try {
    const decryptedData = decrypt(encryptedPKCE);
    return JSON.parse(decryptedData);
  } catch (error) {
    console.error("Failed to decrypt PKCE data:", error);
    return null;
  }
};

const extract_token_for_logout = (
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) => {
  const authHeader = req.headers.authorization;
  const token = authHeader && authHeader.split(" ")[1];

  if (!token) {
    return next();
  }

  jwt.verify(token, JWT_SECRET, async (err: any, decoded: any) => {
    if (err) {
      return next(); // handle in next handler
    }

    req.user = decoded as User;
    return next();
  });

  return;
};

const refreshToken = async (
  req: express.Request,
  res: express.Response,
  decoded: any
) => {
  try {
    const encryptedRefreshToken = decoded?.oidcRefreshToken;

    if (!encryptedRefreshToken) {
      return false;
    }

    const oidcRefreshToken = decrypt(encryptedRefreshToken);
    const refreshedTokenSet = await oidc_client.refresh(oidcRefreshToken);

    const newClaims = refreshedTokenSet.claims();
    const newIdTokenDecoded = jwt.decode(
      refreshedTokenSet.id_token as string
    ) as any;

    const refreshedUser = {
      id: newClaims.sub || decoded.id,
      email: newClaims.email || decoded.email,
      preferred_username:
        newClaims.preferred_username || decoded.preferred_username,
      roles: newIdTokenDecoded?.realm_access?.roles || decoded.roles || [],
    };

    // Generate new JWT
    const newSessionAccessToken = generateJWT(
      refreshedUser,
      refreshedTokenSet.refresh_token as string
    );

    res.setHeader("X-New-Access-Token", newSessionAccessToken);
    res.setHeader("X-Token-Refreshed", "true");

    req.user = refreshedUser;
    return true;
  } catch (refreshError) {
    // probably SSO logout or client session expired
    console.error("Token refresh failed:", refreshError);
    return false;
  }
};

const verifyTokenWithAutoRefresh = (
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) => {
  const authHeader = req.headers.authorization;
  const token = authHeader && authHeader.split(" ")[1];

  if (!token) {
    return res.status(400).json({ error: "Access token required" });
  }

  jwt.verify(token, JWT_SECRET, async (err: any, decoded: any) => {
    if (err) {
      // If token is expired, try to refresh it
      if (err.name === "TokenExpiredError") {
        if (await refreshToken(req, res, decoded)) {
          req.user = decoded as User;
          return next(); // all good, continue, token refreshed
        }
        return res.status(401).json({
          error: "Session expired",
          requiresReauth: true,
          reason: "sso_logout",
        });
      }
      return res.status(400).json({ error: "Invalid token" });
    }

    req.user = decoded as User;
    return next();
  });

  return;
};
// Routes

// Health check
app.get("/api/health", (req, res) => {
  res.json({ status: "OK", timestamp: new Date().toISOString() });
});

// Modern JWT-based auth routes

// redirect here from frontend to start the OIDC flow
app.get("/api/auth/jwt/login", (req, res) => {
  try {
    const codeVerifier = generators.codeVerifier();
    const codeChallenge = generators.codeChallenge(codeVerifier);
    const state = generators.state();

    // You can encode custom URL parameters ( not sensitive data ) provided from the frontend in the state variable
    // e.g., state = encodeURIComponent(JSON.stringify({ state: state, customParam: "value" })).toString('base64');
    // decode after state check in callback route: const params = JSON.parse(Buffer.from(oidc_client.callbackParams(req), 'base64').toString());

    // Store PKCE parameters in encrypted cookie
    storePKCEInCookie(res, codeVerifier, state);

    const authUrl = oidc_client.authorizationUrl({
      scope: "openid email profile",
      code_challenge: codeChallenge,
      code_challenge_method: "S256",
      state: state,
    });

    res.redirect(authUrl);
  } catch (error) {
    console.error("Error initiating OIDC login:", error);
    res.status(500).json({ error: "Failed to initiate login" });
  }
});

// Will be called by Keycloak after successful authentication
// This will redirect to the frontend with the access token
app.get("/api/auth/jwt/callback", async (req, res) => {
  try {
    const params = oidc_client.callbackParams(req);
    const pkceData = retrievePKCEFromCookie(req);

    // Clear PKCE cookie
    res.clearCookie("pkce_data", {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax",
    });

    if (!pkceData) {
      return res.status(400).json({ error: "PKCE data not found or expired" });
    }

    // Verify state parameter
    if (params.state !== pkceData.state) {
      return res.status(400).json({ error: "Invalid state parameter" });
    }

    // Exchange code for tokens
    const tokenSet = await oidc_client.callback(
      KEYCLOAK_CONFIG.callbackURL,
      params,
      { code_verifier: pkceData.codeVerifier, state: params.state }
    );

    // Get user info from the ID token
    const claims = tokenSet.claims();

    // Decode ID token to get additional info like roles
    const idTokenDecoded = jwt.decode(tokenSet.id_token as string) as any;

    // Transform Keycloak profile to our User interface
    const user: User = {
      id: claims.sub || "",
      email: claims.email || "",
      preferred_username: claims.preferred_username || "",
      roles: idTokenDecoded?.realm_access?.roles || [],
      idToken: tokenSet.id_token as string, // Store ID token for logout
    };

    const sessionAccessToken = generateJWT(
      user,
      tokenSet.refresh_token as string
    );

    // Redirect with access token
    const frontendUrl = process.env.FRONTEND_URL as string;
    return res.redirect(
      `${frontendUrl}/auth/callback?token=${sessionAccessToken}`
    );
  } catch (error) {
    console.error("OIDC callback error:", error);
    return res.status(500).json({ error: "Authentication failed" });
  }
});

// Hard logout route
// If JWT is not provided, nothing to do, it will just redirect to frontend URL
app.get("/api/auth/jwt/logout", extract_token_for_logout, (req, res) => {
  // Redirect to Keycloak logout if idToken is present
  if (req.user && req.user.idToken) {
    const logoutUrl = oidc_client.endSessionUrl({
      post_logout_redirect_uri: process.env.FRONTEND_URL as string,
      id_token_hint: req.user.idToken,
      // state: "logout", // can also be used here to pass custom parameters
    });

    return res.redirect(logoutUrl);
  }

  // If no idToken is present, nothing to do, just return success
  // This means the user is not logged in or has already logged out
  const frontendUrl = process.env.FRONTEND_URL as string;
  return res.redirect(frontendUrl);
});

// Call to refresh the access token using the oidc refresh token
app.post("/api/auth/jwt/refresh", (req, res, next) => {
  const authHeader = req.headers.authorization;
  const token = authHeader && authHeader.split(" ")[1];

  if (!token) {
    return res.status(400).json({ error: "Access token required" });
  }

  jwt.verify(token, JWT_SECRET, async (err: any, decoded: any) => {
    if (err && err.name !== "TokenExpiredError") {
      return res.status(400).json({ error: "Invalid token" });
    }

    if (await refreshToken(req, res, decoded)) {
      return res.status(200).json({ message: "Success" });
    }
    return res.status(401).json({
      error: "Session expired",
      requiresReauth: true,
      reason: "sso_logout",
    });
  });

  return;
});

// JWT protected route
app.get("/api/user", verifyTokenWithAutoRefresh, (req, res) => {
  res.json({ user: req.user });
});

// JWT Admin protected route
app.get("/api/admin/resource", verifyTokenWithAutoRefresh, (req, res) => {
  const user = req.user as User;

  if (!user.roles || !user.roles.includes("admin")) {
    return res.status(403).json({ error: "Access denied" });
  }

  return res.json({
    message: "Success",
    timestamp: new Date().toISOString(),
  });
});

// Error handling middleware
app.use(
  (
    err: any,
    req: express.Request,
    res: express.Response,
    next: express.NextFunction
  ) => {
    console.error(err.stack);
    res.status(500).json({ error: "Something went wrong!" });
  }
);

// frontend handler
app.use(/(.*)/, (req, res) => {
  if (req.path.startsWith("/api")) {
    return res.status(404).send("API route not found");
  }

  return res.sendFile(staticPath + "/index.html");
});

// Initialize OIDC client and start server
initializeOIDCClient().then(() => {
  app.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
    console.log(`Keycloak OIDC configured for: ${KEYCLOAK_CONFIG.issuer}`);
  });
});

export default app;
